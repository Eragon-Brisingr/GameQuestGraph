# 游戏任务系统

## 问题引入

游戏玩法中存在任务驱动的行为，例如任务系统、关卡解密、新手引导等，当任务驱动情况复杂且需要涉及网络同步、序列化等时会导致硬编码的逻辑分散且难以理解（异步编程的常见问题），而若把任务逻辑完全硬编码后给策划配置数值会导致配置表字段暴涨（出现非常多的只针对特例的变量），且策划修改流程是要经过程序开发。

## 目标

提供一套编辑器及运行时的工具解决游戏性任务驱动的问题，能让策划快速方便的配置任务条件，且任务间驱动的关联关系交还给策划配置。

## 解决的问题

1. 任务参数配置，不出现策划表字段暴涨的问题，且存在运行时计算参数的功能
2. 任务驱动关系配置，且要足够灵活，应对所有需求
3. 任务驱动关系的预览，不出现异步编程任务驱动的理解成本过高的问题
4. 网络同步，客户端可以知道之前做了的事情和当前需要做的事情（任务系统、新手引导）
5. 序列化，为了游戏存档后读取当前任务还能继续进行（上古卷轴）
6. 可预览运行时的任务执行情况，减少异步编程调试成本

## 系统概述

<video width="320" height="240" controls>
    <source src="Docs/游戏任务系统演示.wmv" type="video/wmv">
</video>

拓展了蓝图系统，增加了游戏任务类型图表，该图表中可添加任务序列（序列中包含任务元素），任务之间的驱动可额外编写逻辑，直接可以用流程图的形式编写游戏性任务。

## 具体概念

### 任务图

![游戏任务图表](Resources/EventFlowIcon_128x.png)  
所有任务节点的容器，用来概括一个任务情景  

### 任务序列

任务元素的容器，多个任务组元素合成任务序列，元素满足序列完成条件则会进行下一个序列。  

#### 组

![游戏任务元素](Docs/任务序列_分组.png)  
元素可分为多组，同一组的元素为与逻辑，组之间为或逻辑。  

#### 可选元素

![可选元素配置](Docs/可选元素配置.png)  
![可选元素编辑器界面](Docs/可选元素编辑器界面.png)  
标记为可选的元素**不会对序列的完成情况造成影响**。  

#### 序列逻辑类型

1. 顺序序列  
![顺序序列](Docs/任务序列_顺序.png)  
其中的元素满足达成条件则进行下一个序列
2. 分支序列  
![分支序列](Docs/任务序列_分支.png)  
列表中的元素满足完成条件后会激活分支，若分支完成进行分支后的序列。（分支序列中有选择是否中断其它分支，若不中断其它分支则当其他分支结束后会执行对应分支的后继序列）

若有其它特殊逻辑可再定制序列类型（序列的定制不打算暴露给蓝图，需要编写C++）

### 任务元素

![游戏任务元素](Resources/EventFlowElementIcon_128x.png)  
元素是游戏任务系统的基本单位，是游戏任务的驱动力。  
![创建游戏任务元素](Docs/游戏任务元素创建位置.png)  
蓝图可拓展，定制不同的任务情况。

#### 拓展用函数

可重写函数 | 说明
------- | -------
WhenConstruct | 当任务元素构造时触发，一般用作变量的初始化
WhenActive | 当任务激活时触发，用来绑定委托
WhenDeactive | 当任务反激活时触发，用来取消绑定的委托

函数及变量 | 说明
------- | -------
EventFlowFinishEvent | 用作任务结束时的触发，任务分支节点会出现变量名对应的执行引脚
SetElementFinish | 设置该元素已经结束，传入EventFlowFinishEvent触发对应的后继任务
SetElementUnfinish | 设置该元素尚未结束（考虑搜集物品的情景，原本已经搜集完成，但是玩家卖了些导致又回到未完成状态）

#### 本地判定

![本地判定](Docs/本地判定.png)  

* 系统通过这个选项处理网络同步问题，由于存在一些情况任务只会在客户端发生（输入行为等），添加本地判定选项
* 为真时任务元素会在**主控端**激活，**SetElementFinish**函数中的*EventName***必须填写**为传入的*OnElementFinishedEvent*参数的**属性名**
* 只有在任务元素在主控端激活的情况下才会向服务器发送元素结束的RPC请求，任务的广播方就不用考虑网络的问题了

#### 特殊元属性

引用和软引用的属性细节面板额外添加了元属性**MustHaveValue**，为真时游戏任务图表编译时若属性值为空则会产生**编译错误**

#### EvaluateEventFlowParameter

* EvaluateEventFlowParameter为游戏任务用来动态求值的结构体，用以从游戏任务图表向游戏任务元素中传递数据  
* 命名格式为Evaluate<属性名>，例如EvaluateDescribe，则会求值Describe属性  
* 调用**IsBound**查询是否进行了属性绑定
* 调用**Evaluate**进行对应属性的求值  

#### 示例

![游戏任务元素编写示例](Docs/游戏任务元素定制示例.png)  
声明了**目的地**变量，**到达了**后继任务  
当**激活**时向所有者**绑定**了Overlap任务，用于检查是否在区域内，Begin时完成，End时取消完成  
当**反激活**时**取消绑定**  

### 中断

![游戏任务元素编写示例](Docs/中断节点.png)  
中断指定的任务节点，若对应节点尚未激活时会尝试中断该节点之前的激活节点，若对应节点已经完成，则中断后继激活节点  

## 游戏任务编辑器  

### 界面介绍  

![任务图编辑器概览](Docs/任务图编辑器概览.png)  
编辑器布局就是蓝图布局，操作和蓝图基本一致，添加了任务图表  

1. 任务起始节点用作游戏任务系统的触发，激活后续的时间序列节点  
2. 任务节点  
![容器节点右键面板](Docs/容器节点右键面板.png)  
容器型右键可添加元素  
3. 细节面板，提供了任务编辑器的特殊操作  
![容器节点右键面板](Docs/细节面板.png)  
    1. 是否暴露引脚的开关  
    ![引脚开关关](Docs/引脚开关关.png)  
    引脚开关关  
    ![引脚开关开](Docs/引脚开关开.png)  
    引脚开关开  
    引脚必须存在连接，否则编译时会报错  
    2. 属性配置，若引脚开关关并且不存在函数绑定时可配置  

### 调试

![调试界面](Docs/调试界面.png)  
调试支持所有的蓝图调试操作，且标注了节点的当前状态  

节点状态 | 对应颜色
------- | -------
激活 | 绿色
未激活 | 黑色
完成 | 蓝色
中断 | 红色

* ![调试强制完成元素](Docs/调试强制完成元素.png)  
调试时右键激活的节点可以强制完成

* ![强制跳转执行](Docs/强制跳转执行.png)  
调试服务端对象时右键节点可强制跳转执行该节点  

* ![游戏任务调试面板](Docs/游戏任务调试面板.png)  
游戏任务调试面板会显示当前调试的任务树，点击可跳转到对应节点

#### 命令行强制完成

![命令行强制完成元素](Docs/命令行强制完成元素.png)  

* 总控：
EventFlow.EnableCmdFinish <0:关闭/1:打开>（非Shipping模式默认打开）  

* 强制完成元素  
PIE模式格式：EventFlow.FinishElement.\<Server/Client0>.<游戏任务类型名>.<任务元素全名>  
非PIE模式格式：EventFlow.FinishElement.\<游戏任务类型名>.<任务元素全名>  

* 强制完成顺序序列：  
PIE模式格式：EventFlow.FinishElement.\<Server/Client0>.<游戏任务类型名>.<序列名>  
非PIE模式格式：EventFlow.FinishElement.\<游戏任务类型名>.<序列名>  

* 强制完成分支序列：  
PIE模式格式：EventFlow.FinishElement.\<Server/Client0>.<游戏任务类型名>.<序列名>.<分支元素名>  
非PIE模式格式：EventFlow.FinishElement.\<游戏任务类型名>.<序列名>.<分支元素名>  

### 命名空间

考虑到**任务元素**可能对应不同的**情景**（世界的任务、角色的任务、队伍的任务...），这将会对应不同的**任务图表基类**，所以添加了**命名空间**的概念。  

1. ![创建任务图表上下文](Docs/创建任务图表上下文.png)  
任务图表假如是**Abstract**的，则会认为这是一类任务的基类，会在创建任务图表的上下文中出现。  
2. ![创建任务元素上下文](Docs/创建任务元素上下文.png)  
创建任务元素时会出现选择对应的任务图表的选项，设置了则该任务元素只会出现在指定的任务图表子类下。  
3. ![激活游戏任务节点](Docs/激活游戏任务节点.png)  
**游戏任务管理器的子类**需要配置**支持的游戏任务图表类型**，这样的话在ActiveEventFlow节点中只会显示支持的游戏任务类型。

## 运行时

* 提供了EventFlowManager组件管理任务图表，调用**ActiveEventFlow**节点激活游戏任务  
* 该系统运行时Element提供Tick任务，需要勾选**AllowTick**后，才会在节点**激活**时执行Tick。  
* 系统中每个序列或元素节点在运行时对应**一个UObject**，且只有节点**激活时才会实例化**

### 运行时UI

* 游戏任务细节控件  
![游戏任务细节控件位置](Docs/游戏任务细节控件位置.png)  
![游戏任务细节控件](Docs/游戏任务细节控件.png)  
提供了运行时可视化游戏任务的控件，会树状显示已经完成和当前激活的任务。控件调用**SetEventFlow**设置当前预览的游戏任务。

## 原理解释

![游戏任务系统编译展开节点](Docs/游戏任务系统编译展开节点.png)  
每个游戏任务序列在编译时会将节点的内容展开，调用序列和元素的序列化、赋值节点，并对后继节点进行任务绑定。  

## 性能

* 时间开销  
运行时基本没有什么性能开销，基本都是O(1)操作  
O(n)的操作的n基本为元素的数量，由于n数量太小问题不大  
* 空间开销  
当序列被激活时会创建序列和其中元素对应的Object  
Object基类56B，就算给每个任务图给10KB的预算都可以容纳很多节点的激活了  

## 单元测试

由于将任务和流程在框架里做了解耦，每个任务元素可以写对应的单元测试。  
这是我个人的意淫，假如能做的话最好了。（参考盗贼之海的QA分享）

## 扯点别的  

TODO：编译报错之类的，工程向的东西  

## 项目历史  

TODO  

## 同类系统

* 巫师3任务系统  
![巫师3任务系统](Docs/巫师3任务系统.png)  
* 刺客信条奥德赛  
![巫师3任务系统](Docs/刺客信条奥德赛.png)  
* 底特律·成为人类
![底特律变人流程图](Docs/底特律变人流程图.jpg)  

## 参考

[巫师3对白生成系统](https://www.youtube.com/watch?v=chf3REzAjgI)（用任务系统来驱动）
